{"version":3,"sources":["../src/index.ts","../src/classes/http-transport.ts","../src/classes/notification-target.ts","../src/classes/watch.ts","../src/classes/http-transport-factory.ts"],"sourcesContent":["export { UseHttp } from \"./classes/http-transport-factory\";","import { BehaviorClass, BehaviorId, IStateflowsClientTransport, SendResult, JsonUtils, IWatcher, CompoundRequest } from \"@stateflows/common\";\r\nimport { NotificationTarget } from \"./notification-target\";\r\nimport { Watch } from \"./watch\";\r\nimport { EventHolder, NotificationsRequest } from \"@stateflows/common\";\r\n\r\nexport class HttpTransport implements IStateflowsClientTransport {\r\n    #targets: Map<string, NotificationTarget> = new Map<string, NotificationTarget>();\r\n    #notificationIds: Array<string> = [];\r\n    #watchInterval: ReturnType<typeof setInterval>;\r\n\r\n    constructor(private url: string) {\r\n        if (url.slice(-1) != '/') {\r\n            url = url + '/';\r\n        }\r\n\r\n        // setInterval(async () => {\r\n        //     if (this.#targets.size === 0) {\r\n        //         return;\r\n        //     }\r\n\r\n        //     this.#targets.forEach(async target => {\r\n        //         await this.send(target.behaviorId, new EventHolder(new NotificationsRequest()));\r\n        //     });\r\n        // }, 10 * 1000);\r\n    }\r\n\r\n    private updateTimestamp(responseTime: string) {\r\n        this.#targets.forEach(target => {\r\n            target.watches.forEach(watch => {\r\n                watch.lastNotificationCheck = responseTime;\r\n                delete watch.milisecondsSinceLastNotificationCheck;\r\n            });\r\n        });\r\n    }\r\n\r\n    private handleNotifications(notifications: Array<EventHolder>, responseTime: string | null = null) {\r\n        for (const target of this.#targets.values()) {\r\n            target.watches.forEach(watch => {\r\n                watch.lastNotificationCheck = responseTime;\r\n                delete watch.milisecondsSinceLastNotificationCheck;\r\n            });\r\n        }\r\n\r\n        const notificationsMap = new Map<string, EventHolder[]>();\r\n\r\n        notifications.forEach(notification => {\r\n            if (this.#notificationIds.includes(notification.id)) {\r\n                return;\r\n            }\r\n            delete (notification.senderId as any).$type;\r\n            delete (notification.senderId.behaviorClass as any).$type;\r\n            delete (notification.senderId.behaviorClass as any).environment;\r\n            const senderId = JsonUtils.stringify(notification.senderId);\r\n\r\n            notificationsMap.set(\r\n                senderId,\r\n                notificationsMap.has(senderId)\r\n                    ? [...notificationsMap.get(senderId), notification]\r\n                    : [notification]\r\n            );\r\n        });\r\n\r\n        for (const senderId of notificationsMap.keys()) {\r\n            const notifications = notificationsMap.get(senderId);\r\n            const target = this.#targets.get(senderId);\r\n            if (typeof target !== 'undefined') {\r\n                const notificationNames = target.watches.map(watch => watch.notificationName);\r\n                target.handleNotifications(notifications.filter(notification => notificationNames.indexOf(notification.name) !== -1));\r\n            }\r\n        }\r\n\r\n        this.#notificationIds = notifications.map(notification => notification.id);\r\n        // if (responseTime !== null) {\r\n        //     this.updateTimestamp(responseTime);\r\n        // }\r\n        \r\n        // notifications.forEach(notification => {\r\n        //     if (this.#notificationIds.includes(notification.id)) {\r\n        //         return;\r\n        //     }\r\n        //     delete (notification.senderId.behaviorClass as any).environment;\r\n        //     let target = this.#targets.get(JsonUtils.stringify(notification.senderId));\r\n        //     console.log(notification, this.#targets, JsonUtils.stringify(notification.senderId));\r\n\r\n        //     if (typeof target !== 'undefined') {\r\n        //         target.watches.forEach(watch => {\r\n        //             if (watch.notificationName === notification.name) {\r\n        //                 target.handleNotifications([notification.payload]);\r\n        //             }\r\n        //         });\r\n        //     }\r\n        // });\r\n\r\n        // this.#notificationIds = notifications.map(notification => notification.id);\r\n    }\r\n\r\n    private getWatches(behaviorId: BehaviorId) {\r\n        behaviorId = JsonUtils.deepClone(behaviorId);\r\n        delete (behaviorId as any).$type;\r\n        delete (behaviorId.behaviorClass as any).$type;\r\n        const behaviorIdString = JsonUtils.stringify(behaviorId);\r\n        if (this.#targets.has(behaviorIdString)) {\r\n            let target = this.#targets.get(behaviorIdString);\r\n            return target.watches.map(watch => {\r\n                return {\r\n                    notificationName: watch.notificationName,\r\n                    lastNotificationCheck: watch.lastNotificationCheck,\r\n                    milisecondsSinceLastNotificationCheck: watch.milisecondsSinceLastNotificationCheck !== null\r\n                        ? Date.now() - watch.milisecondsSinceLastNotificationCheck\r\n                        : null,\r\n                };\r\n            });\r\n        } else {\r\n            return [];\r\n        }\r\n        // if (this.#targets.has(JsonUtils.stringify(behaviorId))) {\r\n        //     let target = this.#targets.get(JsonUtils.stringify(behaviorId));\r\n        //     return target.watches.map(watch => {\r\n        //         return {\r\n        //             notificationName: watch.notificationName,\r\n        //             lastNotificationCheck: watch.lastNotificationCheck,\r\n        //             milisecondsSinceLastNotificationCheck: watch.milisecondsSinceLastNotificationCheck !== null\r\n        //                 ? Date.now() - watch.milisecondsSinceLastNotificationCheck\r\n        //                 : null,\r\n        //         };\r\n        //     });\r\n        // } else {\r\n        //     return [];\r\n        // }\r\n    }\r\n\r\n    async getAvailableClasses(): Promise<BehaviorClass[]> {\r\n        let result = await fetch(`${this.url}stateflows/availableClasses`);\r\n        return await result.json() as BehaviorClass[];\r\n    }\r\n    \r\n    async send(behaviorId: BehaviorId, event: EventHolder): Promise<SendResult> {\r\n        const eventNameParts = event.payload.$type.split(',')[0].split('.');\r\n        let eventName = eventNameParts[eventNameParts.length - 1];\r\n        if (eventName === 'CompoundRequest') {\r\n            const eventNames = (event.payload as CompoundRequest).events.map(event => {\r\n                const eventNameParts = (event as any).$type.split(',')[0].split('.');\r\n                return eventNameParts[eventNameParts.length - 1];\r\n            });\r\n            eventName = eventNames.join(',');\r\n        }\r\n        let result = await fetch(\r\n            `${this.url}stateflows/send?${eventName}`,\r\n            {\r\n                method: \"POST\",\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JsonUtils.stringify({\r\n                    \"$type\": \"Stateflows.Common.Transport.Classes.StateflowsRequest, Stateflows.Common.Transport\",\r\n                    behaviorId: behaviorId,\r\n                    event,\r\n                    watches: this.getWatches(behaviorId)\r\n                })\r\n            }\r\n        );\r\n        \r\n        let stateflowsResponse = await result.json();\r\n        let response = stateflowsResponse.response;\r\n        let validation = stateflowsResponse.validation;\r\n        if (response) {\r\n            event.payload.response = response.payload;\r\n        }\r\n\r\n        this.handleNotifications(stateflowsResponse.notifications, stateflowsResponse.responseTime);\r\n\r\n        let sendResult = new SendResult(event, stateflowsResponse.eventStatus, validation);\r\n\r\n        return sendResult;\r\n    }\r\n\r\n    async watch(watcher: IWatcher, notificationName: string): Promise<void> {\r\n        if (this.#watchInterval == undefined) {\r\n            this.#watchInterval = setInterval(this.watchIntervalCallback.bind(this), 10 * 1000);\r\n        }\r\n        const behaviorId = JsonUtils.deepClone(watcher.id);\r\n        delete (behaviorId as any).$type;\r\n        delete (behaviorId.behaviorClass as any).$type;\r\n        const behaviorIdString = JsonUtils.stringify(behaviorId);\r\n        let target = this.#targets.has(behaviorIdString)\r\n            ? this.#targets.get(behaviorIdString) as NotificationTarget\r\n            : new NotificationTarget(watcher);\r\n\r\n        this.#targets.set(behaviorIdString, target);\r\n\r\n        let watchIndex = target.watches.findIndex(watch => watch.notificationName === notificationName);\r\n        if (watchIndex === -1) {\r\n            target.watches.push(new Watch(notificationName, Date.now()));\r\n        }\r\n        // let target = this.#targets.has(JsonUtils.stringify(watcher.id))\r\n        //     ? this.#targets.get(JsonUtils.stringify(watcher.id)) as NotificationTarget\r\n        //     : new NotificationTarget(watcher);\r\n\r\n        // this.#targets.set(JsonUtils.stringify(watcher.id), target);\r\n\r\n        // let watchIndex = target.watches.findIndex(watch => watch.notificationName === notificationName);\r\n        // if (watchIndex === -1) {\r\n        //     target.watches.push(new Watch(notificationName, Date.now()));\r\n        // }\r\n    }\r\n\r\n    async unwatch(watcher: IWatcher, notificationName: string): Promise<void> {\r\n        if (this.#targets.has(JsonUtils.stringify(watcher.id))) {\r\n            let target = this.#targets.get(JsonUtils.stringify(watcher.id)) as NotificationTarget;\r\n            let index = target.watches.findIndex(watch => watch.notificationName === notificationName);\r\n            if (index !== -1) {\r\n                delete target.watches[index];\r\n            }\r\n            this.#targets.delete(JsonUtils.stringify(watcher.id));\r\n        }\r\n    }\r\n\r\n    private async watchIntervalCallback() {\r\n        if (this.#targets.size === 0) {\r\n            return;\r\n        }\r\n\r\n        this.#targets.forEach(async target => {\r\n            await this.send(target.behaviorId, new EventHolder(new NotificationsRequest()));\r\n        });\r\n    } \r\n}","import { BehaviorId } from \"@stateflows/common\";\r\nimport { IWatcher } from \"@stateflows/common\";\r\nimport { Watch } from \"./watch\";\r\n\r\nexport class NotificationTarget {\r\n    #watcher: IWatcher;\r\n\r\n    constructor(watcher: IWatcher) {\r\n        this.#watcher = watcher;\r\n    }\r\n\r\n    watches: Array<Watch> = [];\r\n\r\n    get behaviorId(): BehaviorId {\r\n        return this.#watcher.id;\r\n    }\r\n\r\n    handleNotifications(notifications: Array<any>) {\r\n        let notificationNames = this.watches.map(watch => watch.notificationName);\r\n        notifications.forEach(notification => {\r\n            if (notificationNames.indexOf(notification.name) !== -1) {\r\n                this.#watcher.notify(notification);\r\n            }\r\n        });\r\n    }\r\n}","import { NotificationHandler } from \"@stateflows/common\";\r\n\r\nexport class Watch {\r\n    constructor(\r\n        public notificationName: string,\r\n        public milisecondsSinceLastNotificationCheck: number    \r\n    ) {}\r\n\r\n    handlers: Array<NotificationHandler<any>> = [];\r\n    notifications: Array<any> = [];\r\n    lastNotificationCheck: string;\r\n}","import { IStateflowsClientTransport, IStateflowsClientTransportFactory } from \"@stateflows/common\";\r\nimport { HttpTransport } from \"./http-transport\";\r\n\r\nexport class HttpTransportFactory implements IStateflowsClientTransportFactory {\r\n    constructor(private url: string) {}\r\n\r\n    getTransport(): Promise<IStateflowsClientTransport> {\r\n        return Promise.resolve(new HttpTransport(this.url));\r\n    }\r\n}\r\n\r\nexport function UseHttp(url: string): IStateflowsClientTransportFactory {\r\n    return new HttpTransportFactory(url);\r\n}"],"mappings":"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","names":["index_exports","__export","UseHttp","__toCommonJS","import_common","_watcher","NotificationTarget","watcher","__privateAdd","__privateSet","__privateGet","notifications","notificationNames","watch","notification","Watch","notificationName","milisecondsSinceLastNotificationCheck","import_common","_targets","_notificationIds","_watchInterval","HttpTransport","url","__privateAdd","responseTime","__privateGet","target","watch","notifications","notificationsMap","notification","senderId","notificationNames","__privateSet","behaviorId","behaviorIdString","event","eventNameParts","eventName","stateflowsResponse","response","validation","watcher","notificationName","NotificationTarget","Watch","index","HttpTransportFactory","url","HttpTransport","UseHttp"]}